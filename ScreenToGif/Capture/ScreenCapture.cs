using ScreenToGif.Domain.Models.Recording.Events;
using ScreenToGif.Model;
using ScreenToGif.Util;
using System;
using System.Collections.Concurrent;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;

namespace ScreenToGif.Capture;

internal class ScreenCapture : BaseCapture, IScreenCapture
{
    private FileStream _eventsFileStream;
    private BufferedStream _eventsBufferedStream;
    private Task _eventConsumerTask;
    private BlockingCollection<RecordingEvent> _eventConsumer;

    #region Properties

    public int Left { get; set; }

    public int Top { get; set; }

    /// <summary>
    /// The image in pixels of the cursor.
    /// </summary>
    public byte[] Cursor { get; set; }

    public int CursorWidth { get; set; }

    public int CursorHeight { get; set; }

    /// <summary>
    /// The name of the monitor device where the recording is supposed to happen.
    /// </summary>
    public string DeviceName { get; set; }

    #endregion

    public virtual void Start(int delay, int left, int top, int width, int height, double scale, ProjectInfo project)
    {
        base.Start(delay, width, height, scale, project);

        Left = left;
        Top = top;

        //_eventsFileStream = new FileStream(project.CachePath, FileMode.Create, FileAccess.Write, FileShare.None);
        //_eventsBufferedStream = new BufferedStream(_eventsFileStream, 10 * 1048576); //Each 1 MB has 1_048_576 bytes.

        //ConfigureEventConsumer();
    }

    private void ConfigureEventConsumer()
    {
        _eventConsumer ??= new BlockingCollection<RecordingEvent>();

        //Spin up a Task to consume the events generated by the recorder.
        _eventConsumerTask = Task.Factory.StartNew(() =>
        {
            try
            {
                while (true)
                    Save(FrameConsumer.Take());
            }
            catch (InvalidOperationException)
            {
                //It means that Take() was called on a completed collection.
            }
            catch (Exception e)
            {
                Application.Current.Dispatcher.Invoke(() => OnError?.Invoke(e));
            }
        });
    }

    public virtual int CaptureWithCursor(FrameInfo frame)
    {
        return 0;
    }

    public virtual Task<int> CaptureWithCursorAsync(FrameInfo frame)
    {
        return null;
    }

    public virtual int ManualCapture(FrameInfo frame, bool showCursor = false)
    {
        return showCursor ? CaptureWithCursor(frame) : Capture(frame);
    }

    public virtual Task<int> ManualCaptureAsync(FrameInfo frame, bool showCursor = false)
    {
        return showCursor ? CaptureWithCursorAsync(frame) : CaptureAsync(frame);
    }

    public void RegisterCursorEvent(long ticksSinceStart, int x, int y, MouseButton button)
    {
        _eventConsumer.Add(new CursorEvent
        {
            TimeStampInTicks = ticksSinceStart,
            Left = Left - x,
            Top = Top - y,
            Width = 0,
            Height = 0,
            Pixels = Cursor.ToArray()
        });
    }

    public virtual void SaveCursorEvent(long ticksSinceStart, int x, int y, MouseButton button)
    {
        if (Cursor == null)
            return;

        _eventsBufferedStream.WriteByte(1); //Cursor event type.
        _eventsBufferedStream.WriteUInt64((ulong) ticksSinceStart); //TimeStamp since capture start.
        _eventsBufferedStream.WriteInt32(Left - x);
        _eventsBufferedStream.WriteInt32(Top - y);

        _eventsBufferedStream.WriteBytes(Cursor);
    }

    public virtual void SaveKeyEvent(long ticksSinceStart, Key key, ModifierKeys modifiers)
    {
        //Same questions.
    }

    private void PersistEvent()
    {

    }

    //Create WebcamCapture and SketchboardCapture classes.
    //WebcamCapture needs and overhaul (possibily using WinRT methods, limiting to newer versions).
}